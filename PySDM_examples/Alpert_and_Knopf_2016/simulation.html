<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PySDM_examples.Alpert_and_Knopf_2016.simulation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PySDM_examples.Alpert_and_Knopf_2016.simulation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Union

import matplotlib
import numpy as np
from matplotlib import pyplot
from packaging import version

from PySDM import Builder, Formulae
from PySDM.backends import CPU
from PySDM.dynamics import Freezing
from PySDM.environments import Box
from PySDM.initialisation import discretise_multiplicities
from PySDM.initialisation.sampling import spectral_sampling
from PySDM.physics import constants as const
from PySDM.physics import si
from PySDM.products import IceWaterContent, TotalUnfrozenImmersedSurfaceArea


class Simulation:
    # note: dv and droplet_volume are dummy multipliers (multiplied and then divided by)
    #       will become used if coalescence or other processes are turned on
    def __init__(
        self,
        *,
        cases,
        n_runs_per_case=10,
        multiplicity=1,
        time_step,
        droplet_volume=1 * si.um**3,
        heterogeneous_ice_nucleation_rate=&#34;Constant&#34;,
        total_time: Union[None, float] = None,
        temperature_range: Union[None, tuple] = None,
    ):
        self.cases = cases
        self.n_runs_per_case = n_runs_per_case
        self.multiplicity = multiplicity
        self.volume = cases.volume
        self.time_step = time_step
        self.droplet_volume = droplet_volume
        self.heterogeneous_ice_nucleation_rate = heterogeneous_ice_nucleation_rate
        self.output = None
        self.total_time = total_time
        self.temperature_range = temperature_range

    def run(self, keys):
        self.output = {}
        for key in keys:
            case = self.cases[key]

            assert (self.total_time is None) + (self.temperature_range is None) == 1
            if self.total_time is not None:
                total_time = self.total_time
            else:
                total_time = (
                    np.diff(np.asarray(self.temperature_range)) / case[&#34;cooling_rate&#34;]
                )

            constants = None
            if &#34;J_het&#34; not in case:
                case[&#34;J_het&#34;] = None
                constants = {&#34;ABIFM_C&#34;: case[&#34;ABIFM_c&#34;], &#34;ABIFM_M&#34;: case[&#34;ABIFM_m&#34;]}
            if &#34;cooling_rate&#34; not in case:
                case[&#34;cooling_rate&#34;] = 0
                constants = {&#34;J_HET&#34;: case[&#34;J_het&#34;]}

            self.output[key] = []
            for i in range(self.n_runs_per_case):
                number_of_real_droplets = case[&#34;ISA&#34;].norm_factor * self.volume
                n_sd = number_of_real_droplets / self.multiplicity
                np.testing.assert_approx_equal(n_sd, int(n_sd))
                n_sd = int(n_sd)
                initial_temp = (
                    self.temperature_range[1] if self.temperature_range else np.nan
                )
                f_ufz, a_tot = simulation(
                    constants=constants,
                    seed=i,
                    n_sd=n_sd,
                    time_step=self.time_step,
                    volume=self.volume,
                    spectrum=case[&#34;ISA&#34;],
                    droplet_volume=self.droplet_volume,
                    multiplicity=self.multiplicity,
                    total_time=total_time,
                    number_of_real_droplets=number_of_real_droplets,
                    cooling_rate=self.cases[key][&#34;cooling_rate&#34;],
                    heterogeneous_ice_nucleation_rate=self.heterogeneous_ice_nucleation_rate,
                    initial_temperature=initial_temp,
                )
                self.output[key].append({&#34;f_ufz&#34;: f_ufz, &#34;A_tot&#34;: a_tot})

    def plot(self, ylim, grid=None):
        pyplot.rc(&#34;font&#34;, size=10)
        for key in self.output:
            for run in range(self.n_runs_per_case):
                time = self.time_step * np.arange(len(self.output[key][run][&#34;f_ufz&#34;]))
                if self.cases[key][&#34;cooling_rate&#34;] == 0:
                    plot_x = time / si.min
                    plot_y = self.output[key][run][&#34;f_ufz&#34;]
                else:
                    plot_x = (
                        self.temperature_range[1]
                        - time * self.cases[key][&#34;cooling_rate&#34;]
                    )
                    plot_y = 1 - np.asarray(self.output[key][run][&#34;f_ufz&#34;])
                pyplot.step(
                    plot_x,
                    plot_y,
                    label=self.cases.label(key) if run == 0 else None,
                    color=self.cases[key][&#34;color&#34;],
                    linewidth=0.666,
                )
        key = None
        if version.parse(matplotlib.__version__) &gt;= version.parse(&#34;3.3.0&#34;):
            pyplot.gca().set_box_aspect(1)
        pyplot.legend()
        if grid is not None:
            pyplot.grid(which=grid)
        pyplot.ylim(ylim)
        if self.temperature_range:
            pyplot.xlim(*self.temperature_range)
            pyplot.xlabel(&#34;T / K&#34;)
            pyplot.ylabel(&#34;$f_{frz}$&#34;)
        else:
            pyplot.xlim(0, self.total_time / si.min)
            pyplot.xlabel(&#34;t / min&#34;)
            pyplot.ylabel(&#34;$f_{ufz}$&#34;)
            pyplot.yscale(&#34;log&#34;)

    def plot_j_het(self, variant: str, abifm_params_case: str, ylim=None):
        assert variant in (&#34;apparent&#34;, &#34;actual&#34;)

        formulae = Formulae(
            particle_shape_and_density=&#34;MixedPhaseSpheres&#34;,
            heterogeneous_ice_nucleation_rate=&#34;ABIFM&#34;,
            constants={
                &#34;ABIFM_M&#34;: self.cases[abifm_params_case][&#34;ABIFM_m&#34;],
                &#34;ABIFM_C&#34;: self.cases[abifm_params_case][&#34;ABIFM_c&#34;],
            },
        )

        yunit = 1 / si.cm**2 / si.s
        svp = formulae.saturation_vapour_pressure
        plot_x = np.linspace(*self.temperature_range) * si.K
        plot_y = formulae.heterogeneous_ice_nucleation_rate.j_het(
            svp.ice_Celsius(plot_x - const.T0) / svp.pvs_Celsius(plot_x - const.T0)
        )
        pyplot.grid()
        pyplot.plot(plot_x, plot_y / yunit, color=&#34;red&#34;, label=&#34;ABIFM $J_{het}$&#34;)

        for key in self.output:
            for run in range(self.n_runs_per_case):
                time = self.time_step * np.arange(len(self.output[key][run][&#34;f_ufz&#34;]))
                if self.cases[key][&#34;cooling_rate&#34;] == 0:
                    raise NotImplementedError()

                temperature = (
                    self.temperature_range[1] - time * self.cases[key][&#34;cooling_rate&#34;]
                )
                spec = self.cases[key][&#34;ISA&#34;]

                particle_number = spec.norm_factor * self.volume
                n_ufz = particle_number * np.asarray(self.output[key][run][&#34;f_ufz&#34;])
                n_frz = particle_number - n_ufz

                j_het = np.diff(n_frz) / self.time_step
                if variant == &#34;apparent&#34;:
                    j_het /= n_ufz[:-1] * spec.m_mode
                else:
                    a_tot = np.asarray(self.output[key][run][&#34;A_tot&#34;][:-1])
                    j_het = np.divide(
                        j_het, a_tot, out=np.zeros_like(j_het), where=a_tot != 0
                    )

                pyplot.scatter(
                    temperature[:-1] + np.diff(temperature) / 2,
                    np.where(j_het != 0, j_het, np.nan) / yunit,
                    label=self.cases.label(key) if run == 0 else None,
                    color=self.cases[key][&#34;color&#34;],
                )
        key = None

        pyplot.yscale(&#34;log&#34;)
        pyplot.xlabel(&#34;K&#34;)
        pyplot.ylabel(
            f&#34;$J_{{het}}$, $J_{{het}}^{{{variant}}}$ / cm$^{{-2}}$ s$^{{-1}}$&#34;
        )
        pyplot.xlim(self.temperature_range)
        if ylim is not None:
            pyplot.ylim(ylim)
        pyplot.legend()
        if version.parse(matplotlib.__version__) &gt;= version.parse(&#34;3.3.0&#34;):
            pyplot.gca().set_box_aspect(1)


def simulation(
    *,
    constants,
    seed,
    n_sd,
    time_step,
    volume,
    spectrum,
    droplet_volume,
    multiplicity,
    total_time,
    number_of_real_droplets,
    cooling_rate=0,
    heterogeneous_ice_nucleation_rate=&#34;Constant&#34;,
    initial_temperature=np.nan,
):
    formulae = Formulae(
        seed=seed,
        heterogeneous_ice_nucleation_rate=heterogeneous_ice_nucleation_rate,
        constants=constants,
        particle_shape_and_density=&#34;MixedPhaseSpheres&#34;,
    )
    env = Box(dt=time_step, dv=volume)
    builder = Builder(n_sd=n_sd, backend=CPU(formulae=formulae), environment=env)
    builder.add_dynamic(Freezing(singular=False))

    if hasattr(spectrum, &#34;s_geom&#34;) and spectrum.s_geom == 1:
        _isa, _conc = np.full(n_sd, spectrum.m_mode), np.full(
            n_sd, multiplicity / volume
        )
    else:
        _isa, _conc = spectral_sampling.ConstantMultiplicity(spectrum).sample(n_sd)
    attributes = {
        &#34;multiplicity&#34;: discretise_multiplicities(_conc * volume),
        &#34;immersed surface area&#34;: _isa,
        &#34;volume&#34;: np.full(n_sd, droplet_volume),
    }
    np.testing.assert_almost_equal(attributes[&#34;multiplicity&#34;], multiplicity)
    products = (
        IceWaterContent(name=&#34;qi&#34;),
        TotalUnfrozenImmersedSurfaceArea(name=&#34;A_tot&#34;),
    )
    particulator = builder.build(attributes=attributes, products=products)

    env[&#34;T&#34;] = initial_temperature
    env[&#34;a_w_ice&#34;] = np.nan
    env[&#34;RH&#34;] = 1 + np.finfo(float).eps
    svp = particulator.formulae.saturation_vapour_pressure

    cell_id = 0
    f_ufz = []
    a_tot = []
    for i in range(int(total_time / time_step) + 1):
        if cooling_rate != 0:
            env[&#34;T&#34;] -= np.full((1,), cooling_rate * time_step / 2)
            env[&#34;a_w_ice&#34;] = svp.ice_Celsius(env[&#34;T&#34;][0] - const.T0) / svp.pvs_Celsius(
                env[&#34;T&#34;][0] - const.T0
            )
        particulator.run(0 if i == 0 else 1)
        if cooling_rate != 0:
            env[&#34;T&#34;] -= np.full((1,), cooling_rate * time_step / 2)

        ice_mass_per_volume = particulator.products[&#34;qi&#34;].get()[cell_id]
        ice_mass = ice_mass_per_volume * volume
        ice_number = ice_mass / (formulae.constants.rho_w * droplet_volume)
        unfrozen_fraction = 1 - ice_number / number_of_real_droplets
        f_ufz.append(unfrozen_fraction)
        a_tot.append(particulator.products[&#34;A_tot&#34;].get()[cell_id])
    return f_ufz, a_tot</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PySDM_examples.Alpert_and_Knopf_2016.simulation.simulation"><code class="name flex">
<span>def <span class="ident">simulation</span></span>(<span>*, constants, seed, n_sd, time_step, volume, spectrum, droplet_volume, multiplicity, total_time, number_of_real_droplets, cooling_rate=0, heterogeneous_ice_nucleation_rate='Constant', initial_temperature=nan)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulation(
    *,
    constants,
    seed,
    n_sd,
    time_step,
    volume,
    spectrum,
    droplet_volume,
    multiplicity,
    total_time,
    number_of_real_droplets,
    cooling_rate=0,
    heterogeneous_ice_nucleation_rate=&#34;Constant&#34;,
    initial_temperature=np.nan,
):
    formulae = Formulae(
        seed=seed,
        heterogeneous_ice_nucleation_rate=heterogeneous_ice_nucleation_rate,
        constants=constants,
        particle_shape_and_density=&#34;MixedPhaseSpheres&#34;,
    )
    env = Box(dt=time_step, dv=volume)
    builder = Builder(n_sd=n_sd, backend=CPU(formulae=formulae), environment=env)
    builder.add_dynamic(Freezing(singular=False))

    if hasattr(spectrum, &#34;s_geom&#34;) and spectrum.s_geom == 1:
        _isa, _conc = np.full(n_sd, spectrum.m_mode), np.full(
            n_sd, multiplicity / volume
        )
    else:
        _isa, _conc = spectral_sampling.ConstantMultiplicity(spectrum).sample(n_sd)
    attributes = {
        &#34;multiplicity&#34;: discretise_multiplicities(_conc * volume),
        &#34;immersed surface area&#34;: _isa,
        &#34;volume&#34;: np.full(n_sd, droplet_volume),
    }
    np.testing.assert_almost_equal(attributes[&#34;multiplicity&#34;], multiplicity)
    products = (
        IceWaterContent(name=&#34;qi&#34;),
        TotalUnfrozenImmersedSurfaceArea(name=&#34;A_tot&#34;),
    )
    particulator = builder.build(attributes=attributes, products=products)

    env[&#34;T&#34;] = initial_temperature
    env[&#34;a_w_ice&#34;] = np.nan
    env[&#34;RH&#34;] = 1 + np.finfo(float).eps
    svp = particulator.formulae.saturation_vapour_pressure

    cell_id = 0
    f_ufz = []
    a_tot = []
    for i in range(int(total_time / time_step) + 1):
        if cooling_rate != 0:
            env[&#34;T&#34;] -= np.full((1,), cooling_rate * time_step / 2)
            env[&#34;a_w_ice&#34;] = svp.ice_Celsius(env[&#34;T&#34;][0] - const.T0) / svp.pvs_Celsius(
                env[&#34;T&#34;][0] - const.T0
            )
        particulator.run(0 if i == 0 else 1)
        if cooling_rate != 0:
            env[&#34;T&#34;] -= np.full((1,), cooling_rate * time_step / 2)

        ice_mass_per_volume = particulator.products[&#34;qi&#34;].get()[cell_id]
        ice_mass = ice_mass_per_volume * volume
        ice_number = ice_mass / (formulae.constants.rho_w * droplet_volume)
        unfrozen_fraction = 1 - ice_number / number_of_real_droplets
        f_ufz.append(unfrozen_fraction)
        a_tot.append(particulator.products[&#34;A_tot&#34;].get()[cell_id])
    return f_ufz, a_tot</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation"><code class="flex name class">
<span>class <span class="ident">Simulation</span></span>
<span>(</span><span>*, cases, n_runs_per_case=10, multiplicity=1, time_step, droplet_volume=9.999999999999999e-19, heterogeneous_ice_nucleation_rate='Constant', total_time: Optional[float] = None, temperature_range: Optional[None] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulation:
    # note: dv and droplet_volume are dummy multipliers (multiplied and then divided by)
    #       will become used if coalescence or other processes are turned on
    def __init__(
        self,
        *,
        cases,
        n_runs_per_case=10,
        multiplicity=1,
        time_step,
        droplet_volume=1 * si.um**3,
        heterogeneous_ice_nucleation_rate=&#34;Constant&#34;,
        total_time: Union[None, float] = None,
        temperature_range: Union[None, tuple] = None,
    ):
        self.cases = cases
        self.n_runs_per_case = n_runs_per_case
        self.multiplicity = multiplicity
        self.volume = cases.volume
        self.time_step = time_step
        self.droplet_volume = droplet_volume
        self.heterogeneous_ice_nucleation_rate = heterogeneous_ice_nucleation_rate
        self.output = None
        self.total_time = total_time
        self.temperature_range = temperature_range

    def run(self, keys):
        self.output = {}
        for key in keys:
            case = self.cases[key]

            assert (self.total_time is None) + (self.temperature_range is None) == 1
            if self.total_time is not None:
                total_time = self.total_time
            else:
                total_time = (
                    np.diff(np.asarray(self.temperature_range)) / case[&#34;cooling_rate&#34;]
                )

            constants = None
            if &#34;J_het&#34; not in case:
                case[&#34;J_het&#34;] = None
                constants = {&#34;ABIFM_C&#34;: case[&#34;ABIFM_c&#34;], &#34;ABIFM_M&#34;: case[&#34;ABIFM_m&#34;]}
            if &#34;cooling_rate&#34; not in case:
                case[&#34;cooling_rate&#34;] = 0
                constants = {&#34;J_HET&#34;: case[&#34;J_het&#34;]}

            self.output[key] = []
            for i in range(self.n_runs_per_case):
                number_of_real_droplets = case[&#34;ISA&#34;].norm_factor * self.volume
                n_sd = number_of_real_droplets / self.multiplicity
                np.testing.assert_approx_equal(n_sd, int(n_sd))
                n_sd = int(n_sd)
                initial_temp = (
                    self.temperature_range[1] if self.temperature_range else np.nan
                )
                f_ufz, a_tot = simulation(
                    constants=constants,
                    seed=i,
                    n_sd=n_sd,
                    time_step=self.time_step,
                    volume=self.volume,
                    spectrum=case[&#34;ISA&#34;],
                    droplet_volume=self.droplet_volume,
                    multiplicity=self.multiplicity,
                    total_time=total_time,
                    number_of_real_droplets=number_of_real_droplets,
                    cooling_rate=self.cases[key][&#34;cooling_rate&#34;],
                    heterogeneous_ice_nucleation_rate=self.heterogeneous_ice_nucleation_rate,
                    initial_temperature=initial_temp,
                )
                self.output[key].append({&#34;f_ufz&#34;: f_ufz, &#34;A_tot&#34;: a_tot})

    def plot(self, ylim, grid=None):
        pyplot.rc(&#34;font&#34;, size=10)
        for key in self.output:
            for run in range(self.n_runs_per_case):
                time = self.time_step * np.arange(len(self.output[key][run][&#34;f_ufz&#34;]))
                if self.cases[key][&#34;cooling_rate&#34;] == 0:
                    plot_x = time / si.min
                    plot_y = self.output[key][run][&#34;f_ufz&#34;]
                else:
                    plot_x = (
                        self.temperature_range[1]
                        - time * self.cases[key][&#34;cooling_rate&#34;]
                    )
                    plot_y = 1 - np.asarray(self.output[key][run][&#34;f_ufz&#34;])
                pyplot.step(
                    plot_x,
                    plot_y,
                    label=self.cases.label(key) if run == 0 else None,
                    color=self.cases[key][&#34;color&#34;],
                    linewidth=0.666,
                )
        key = None
        if version.parse(matplotlib.__version__) &gt;= version.parse(&#34;3.3.0&#34;):
            pyplot.gca().set_box_aspect(1)
        pyplot.legend()
        if grid is not None:
            pyplot.grid(which=grid)
        pyplot.ylim(ylim)
        if self.temperature_range:
            pyplot.xlim(*self.temperature_range)
            pyplot.xlabel(&#34;T / K&#34;)
            pyplot.ylabel(&#34;$f_{frz}$&#34;)
        else:
            pyplot.xlim(0, self.total_time / si.min)
            pyplot.xlabel(&#34;t / min&#34;)
            pyplot.ylabel(&#34;$f_{ufz}$&#34;)
            pyplot.yscale(&#34;log&#34;)

    def plot_j_het(self, variant: str, abifm_params_case: str, ylim=None):
        assert variant in (&#34;apparent&#34;, &#34;actual&#34;)

        formulae = Formulae(
            particle_shape_and_density=&#34;MixedPhaseSpheres&#34;,
            heterogeneous_ice_nucleation_rate=&#34;ABIFM&#34;,
            constants={
                &#34;ABIFM_M&#34;: self.cases[abifm_params_case][&#34;ABIFM_m&#34;],
                &#34;ABIFM_C&#34;: self.cases[abifm_params_case][&#34;ABIFM_c&#34;],
            },
        )

        yunit = 1 / si.cm**2 / si.s
        svp = formulae.saturation_vapour_pressure
        plot_x = np.linspace(*self.temperature_range) * si.K
        plot_y = formulae.heterogeneous_ice_nucleation_rate.j_het(
            svp.ice_Celsius(plot_x - const.T0) / svp.pvs_Celsius(plot_x - const.T0)
        )
        pyplot.grid()
        pyplot.plot(plot_x, plot_y / yunit, color=&#34;red&#34;, label=&#34;ABIFM $J_{het}$&#34;)

        for key in self.output:
            for run in range(self.n_runs_per_case):
                time = self.time_step * np.arange(len(self.output[key][run][&#34;f_ufz&#34;]))
                if self.cases[key][&#34;cooling_rate&#34;] == 0:
                    raise NotImplementedError()

                temperature = (
                    self.temperature_range[1] - time * self.cases[key][&#34;cooling_rate&#34;]
                )
                spec = self.cases[key][&#34;ISA&#34;]

                particle_number = spec.norm_factor * self.volume
                n_ufz = particle_number * np.asarray(self.output[key][run][&#34;f_ufz&#34;])
                n_frz = particle_number - n_ufz

                j_het = np.diff(n_frz) / self.time_step
                if variant == &#34;apparent&#34;:
                    j_het /= n_ufz[:-1] * spec.m_mode
                else:
                    a_tot = np.asarray(self.output[key][run][&#34;A_tot&#34;][:-1])
                    j_het = np.divide(
                        j_het, a_tot, out=np.zeros_like(j_het), where=a_tot != 0
                    )

                pyplot.scatter(
                    temperature[:-1] + np.diff(temperature) / 2,
                    np.where(j_het != 0, j_het, np.nan) / yunit,
                    label=self.cases.label(key) if run == 0 else None,
                    color=self.cases[key][&#34;color&#34;],
                )
        key = None

        pyplot.yscale(&#34;log&#34;)
        pyplot.xlabel(&#34;K&#34;)
        pyplot.ylabel(
            f&#34;$J_{{het}}$, $J_{{het}}^{{{variant}}}$ / cm$^{{-2}}$ s$^{{-1}}$&#34;
        )
        pyplot.xlim(self.temperature_range)
        if ylim is not None:
            pyplot.ylim(ylim)
        pyplot.legend()
        if version.parse(matplotlib.__version__) &gt;= version.parse(&#34;3.3.0&#34;):
            pyplot.gca().set_box_aspect(1)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ylim, grid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, ylim, grid=None):
    pyplot.rc(&#34;font&#34;, size=10)
    for key in self.output:
        for run in range(self.n_runs_per_case):
            time = self.time_step * np.arange(len(self.output[key][run][&#34;f_ufz&#34;]))
            if self.cases[key][&#34;cooling_rate&#34;] == 0:
                plot_x = time / si.min
                plot_y = self.output[key][run][&#34;f_ufz&#34;]
            else:
                plot_x = (
                    self.temperature_range[1]
                    - time * self.cases[key][&#34;cooling_rate&#34;]
                )
                plot_y = 1 - np.asarray(self.output[key][run][&#34;f_ufz&#34;])
            pyplot.step(
                plot_x,
                plot_y,
                label=self.cases.label(key) if run == 0 else None,
                color=self.cases[key][&#34;color&#34;],
                linewidth=0.666,
            )
    key = None
    if version.parse(matplotlib.__version__) &gt;= version.parse(&#34;3.3.0&#34;):
        pyplot.gca().set_box_aspect(1)
    pyplot.legend()
    if grid is not None:
        pyplot.grid(which=grid)
    pyplot.ylim(ylim)
    if self.temperature_range:
        pyplot.xlim(*self.temperature_range)
        pyplot.xlabel(&#34;T / K&#34;)
        pyplot.ylabel(&#34;$f_{frz}$&#34;)
    else:
        pyplot.xlim(0, self.total_time / si.min)
        pyplot.xlabel(&#34;t / min&#34;)
        pyplot.ylabel(&#34;$f_{ufz}$&#34;)
        pyplot.yscale(&#34;log&#34;)</code></pre>
</details>
</dd>
<dt id="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.plot_j_het"><code class="name flex">
<span>def <span class="ident">plot_j_het</span></span>(<span>self, variant: str, abifm_params_case: str, ylim=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_j_het(self, variant: str, abifm_params_case: str, ylim=None):
    assert variant in (&#34;apparent&#34;, &#34;actual&#34;)

    formulae = Formulae(
        particle_shape_and_density=&#34;MixedPhaseSpheres&#34;,
        heterogeneous_ice_nucleation_rate=&#34;ABIFM&#34;,
        constants={
            &#34;ABIFM_M&#34;: self.cases[abifm_params_case][&#34;ABIFM_m&#34;],
            &#34;ABIFM_C&#34;: self.cases[abifm_params_case][&#34;ABIFM_c&#34;],
        },
    )

    yunit = 1 / si.cm**2 / si.s
    svp = formulae.saturation_vapour_pressure
    plot_x = np.linspace(*self.temperature_range) * si.K
    plot_y = formulae.heterogeneous_ice_nucleation_rate.j_het(
        svp.ice_Celsius(plot_x - const.T0) / svp.pvs_Celsius(plot_x - const.T0)
    )
    pyplot.grid()
    pyplot.plot(plot_x, plot_y / yunit, color=&#34;red&#34;, label=&#34;ABIFM $J_{het}$&#34;)

    for key in self.output:
        for run in range(self.n_runs_per_case):
            time = self.time_step * np.arange(len(self.output[key][run][&#34;f_ufz&#34;]))
            if self.cases[key][&#34;cooling_rate&#34;] == 0:
                raise NotImplementedError()

            temperature = (
                self.temperature_range[1] - time * self.cases[key][&#34;cooling_rate&#34;]
            )
            spec = self.cases[key][&#34;ISA&#34;]

            particle_number = spec.norm_factor * self.volume
            n_ufz = particle_number * np.asarray(self.output[key][run][&#34;f_ufz&#34;])
            n_frz = particle_number - n_ufz

            j_het = np.diff(n_frz) / self.time_step
            if variant == &#34;apparent&#34;:
                j_het /= n_ufz[:-1] * spec.m_mode
            else:
                a_tot = np.asarray(self.output[key][run][&#34;A_tot&#34;][:-1])
                j_het = np.divide(
                    j_het, a_tot, out=np.zeros_like(j_het), where=a_tot != 0
                )

            pyplot.scatter(
                temperature[:-1] + np.diff(temperature) / 2,
                np.where(j_het != 0, j_het, np.nan) / yunit,
                label=self.cases.label(key) if run == 0 else None,
                color=self.cases[key][&#34;color&#34;],
            )
    key = None

    pyplot.yscale(&#34;log&#34;)
    pyplot.xlabel(&#34;K&#34;)
    pyplot.ylabel(
        f&#34;$J_{{het}}$, $J_{{het}}^{{{variant}}}$ / cm$^{{-2}}$ s$^{{-1}}$&#34;
    )
    pyplot.xlim(self.temperature_range)
    if ylim is not None:
        pyplot.ylim(ylim)
    pyplot.legend()
    if version.parse(matplotlib.__version__) &gt;= version.parse(&#34;3.3.0&#34;):
        pyplot.gca().set_box_aspect(1)</code></pre>
</details>
</dd>
<dt id="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, keys):
    self.output = {}
    for key in keys:
        case = self.cases[key]

        assert (self.total_time is None) + (self.temperature_range is None) == 1
        if self.total_time is not None:
            total_time = self.total_time
        else:
            total_time = (
                np.diff(np.asarray(self.temperature_range)) / case[&#34;cooling_rate&#34;]
            )

        constants = None
        if &#34;J_het&#34; not in case:
            case[&#34;J_het&#34;] = None
            constants = {&#34;ABIFM_C&#34;: case[&#34;ABIFM_c&#34;], &#34;ABIFM_M&#34;: case[&#34;ABIFM_m&#34;]}
        if &#34;cooling_rate&#34; not in case:
            case[&#34;cooling_rate&#34;] = 0
            constants = {&#34;J_HET&#34;: case[&#34;J_het&#34;]}

        self.output[key] = []
        for i in range(self.n_runs_per_case):
            number_of_real_droplets = case[&#34;ISA&#34;].norm_factor * self.volume
            n_sd = number_of_real_droplets / self.multiplicity
            np.testing.assert_approx_equal(n_sd, int(n_sd))
            n_sd = int(n_sd)
            initial_temp = (
                self.temperature_range[1] if self.temperature_range else np.nan
            )
            f_ufz, a_tot = simulation(
                constants=constants,
                seed=i,
                n_sd=n_sd,
                time_step=self.time_step,
                volume=self.volume,
                spectrum=case[&#34;ISA&#34;],
                droplet_volume=self.droplet_volume,
                multiplicity=self.multiplicity,
                total_time=total_time,
                number_of_real_droplets=number_of_real_droplets,
                cooling_rate=self.cases[key][&#34;cooling_rate&#34;],
                heterogeneous_ice_nucleation_rate=self.heterogeneous_ice_nucleation_rate,
                initial_temperature=initial_temp,
            )
            self.output[key].append({&#34;f_ufz&#34;: f_ufz, &#34;A_tot&#34;: a_tot})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PySDM_examples.Alpert_and_Knopf_2016" href="index.html">PySDM_examples.Alpert_and_Knopf_2016</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PySDM_examples.Alpert_and_Knopf_2016.simulation.simulation" href="#PySDM_examples.Alpert_and_Knopf_2016.simulation.simulation">simulation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation" href="#PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation">Simulation</a></code></h4>
<ul class="">
<li><code><a title="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.plot" href="#PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.plot">plot</a></code></li>
<li><code><a title="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.plot_j_het" href="#PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.plot_j_het">plot_j_het</a></code></li>
<li><code><a title="PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.run" href="#PySDM_examples.Alpert_and_Knopf_2016.simulation.Simulation.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>